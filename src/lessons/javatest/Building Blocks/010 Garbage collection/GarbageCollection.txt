Всем привет, мы продолжаем цикл видео разбора задач по языку java, которые могут встретиться на экзамене Java SE 17
Developer. Сегодня на разборе простая задача

Какие из следующих утверджений относящиеся к сборщику мусора верны? (Выберите все правильные варианты ответа)

Варианты ответа вы видите на экране. Варианты ответа следующие:

Вариант А: Вызов статического метода gc() класса System гарантирует освобождение памяти за счет уничтожения объектов,
подлежащих сборке мусора
Вариант B: Сборщик мусора запускается по расписанию
Вариант C: Сборщик мусора позволяет JVM освободить память для других объектов
Вариант D: Сборщик мусора запускается, когда ваша программа израсходовала половину доступной памяти
Вариант E: Объект может подлежать сборке мусора, но никогда не удалиться из кучи
Вариант F: Объект подлежит сборке мусора, если в программе нет ссылок на него.
Вариант G: Переменная помеченная как final, означает что ассоциированный с ней объект не может быть подвергнут сборке
мусора

Поставьте видео на паузу, напишите ваш вариант ответа в комментарии, а в конце ролика узнаете, удалось ли вам правильно
ответить на вопрос. Заодно и посмотрим, скольким по силам эта задача. Дам вам еще несколько секунд подумать

(звук таймера)

Надеюсь вы успели сделать свой выбор, потому что мы переходим к разбору этой задачи

Для того, чтобы ответить на данные вопросы, обратимся к документу, который называется "Garbage Collection Tuning". Его
можно найти в документации к 17й JDK на сайте docs.oracle.com

Там в первом разделе, который называется "Введение в настройку сборщика мусора" написано следующее

Сборщик мусора автоматически управляет запросами приложения на динамическое выделение памяти.
Сборщик мусора осуществляет автоматическое динамическое управление памятью через следующие операции
- Выделяет и возващает память операционной системе
- Передаёт эту память приложению по мере его запроса
- Определяет какие части памяти всё еще используются приложением
- Освобождает неиспользуемую память для повторного использования приложением

Далее перейдём к разделу 3, который называется "Реализация сборщика мусора"
Там написано, что Объект считается мусором, и его память может быть повторно использована виртуальной машиной, когда к
нему больше невозможно получить доступ по любой ссылке на любой другой живой объект в работающей программе.

Также в этом разделе рассказывается про то, что можно придумать различные варианты реализации сборщика мусора, например
можно придумать гипотетический "Наивный" вариант реализации, при котором при каждом запуске сборщика мусора перебираются
все объекты в куче и проверяется, считается ли этот объект мусором

Однако при такой реализации Время, которое занимает этот подход, пропорционально количеству действующих объектов, что
недопустимо для крупных приложений, поддерживающих большое количество активных данных.

Поэтому многие сборщики мусора используют подход, который называется "Сборка поколений"

Суть этого подхода заключается в гипотезе, которая заключается в том, что большинство объектов умирают молодыми. Данная
гипотеза подтверждается опытным путём при изучении времени жизни объектов в подавляющем большинстве приложений.

Синяя область на экране представляет собой типичное распределение времени жизни объектов. По оси X показано время жизни
объекта, измеренное в выделенных байтах. Число байтов по оси Y — это общее количество байтов в объектах с
соответствующим временем жизни. Острый пик слева представляет объекты, которые могут считаться мусором вскоре после
создания

Таким образом, чтобы сделать сборку мусора более эффективной, все объекты делятся на два типа: первый тип - это объекты
"Молодого поколения", иными словами те объекты которые были созданы недавно. Второй тип - это объекты "Старого
поколения", то есть те, которые пережили несколько очисток

Когда объектов молодого поколения становится слишком много, вызывается "малая сборка", которая перебирает и удаляет
только молодые объекты, которые считаются мусором. Старые объекты при этом не удаляются.
После того, как молодой объект пережил несколько "Малых сборок", он становится объектом старого поколения.
Когда объектов старого поколения становится слишком много, запускается "большая сборка", которая перебирает и удаляет
все объекты в куче, которые считаются мусором
///
Рассмотрим самую простую реализацию такого сборщика мусора, которая называется Serial GC

Куча условно делится на четыре региона: Эдэм, две области Выживших объектов и область Старых объектов
Одна из областей выживших объектов всегда должна быть пустой. В эту область будут попадать объекты, которые пережили
малую очистку. Пусть в начале программы это будет область S0
При создании объекта он попадает в Эдем
После заполнения области Эдем включается "Малая сборка"
Малая сборка затрагивает объекты, которые находятся в Эдеме и двух дополнительных областях выживших объектов. Все
выжившие объекты попадают в S0. Область S1 остаётся пустой
Далее по мере работы программы область Эдема заполняется еще раз, затем снова включается "Малая сборка" и все выжившие
объекты из эдема и S0 попадают в S1. Теперь S0 снова пустая
Данный процесс повторяется еще раз и все выжившие объекты из эдема и S1 снова попадают в S0
Объекты перемещаются между пространствами S0 и S1 до тех пор, пока они не будут перемещены некоторое количество раз, или
пока там не закончится место. После этого выжившие объекты становятся "Объектами старшего поколения" и перемещаются в
область старых объектов

Когда область старых объектов заполняется, вызывается "Глубокая очистка", которая сканирует все объекты в куче и удаляет
те, к которым больше невозможно получить доступ из программы

Также стоит отметить, что после глубокой очистки в области старых объектов остаются пустые области памяти. Поэтому после
глубокой очистки следует уплотнение этих объектов
///
Также в этом документе в разделе, который называется "Факторы, которые влияют на производительность сборщика мусора"
описывается параметр -XX:NewRatio, который позволяет задать соотношение количества памяти "старых объектов" к количеству
памяти "молодых объектов"

А в подразделе с названием "Явная сборка мусора" написано, что полную сборку мусора можно вызвать явно с помощью вызова
статического метода gc() класса System. Отключить возможность явного вызова можно при помощи параметра
-XX:+DisableExplicitGC

Данной информации достаточно для того чтобы найти верные варианты ответа к этой задаче. Рассмотрим их последовательно

Вариант А утверждает, что вызов статического метода gc() класса System гарантирует освобождение памяти за счет
уничтожения объектов, подлежащих сборке мусора

Данный вариант ответа не является верным, поскольку как мы сказали ранее явный вызов статического метода gc() класса
System можно отключить параметром -XX:+DisableExplicitGC

Вариант B утверждает, что сборщик мусора запускается по расписанию

Данный вариант ответа также не является верным, поскольку, например сборщики мусора, которые используют гипотезу о
поколениях, запускаются по мере заполнения областей памяти

Вариант C: Сборщик мусора позволяет JVM освободить память для других объектов

Данный вариант является верным. Это явно написано в разделе, который называется "Введение в настройку сборщика мусора"

Вариант D: Сборщик мусора запускается, когда ваша программа израсходовала половину доступной памяти

Данный вариант не является верным, поскольку можно задать параметр XX:NewRatio таким образом, чтобы соотношение
количества памяти молодых объектов к количеству памяти "старых объектов" например было один к пяти. В этом случае после
заполнения одной шестой доступной памяти молодых объектов запустится сборщик мусора

Вариант E: Объект может подлежать сборке мусора, но никогда не удалиться из кучи

Данный вариант является верным. Например объект может быть помещён в область старых объектов, потерять все ссылки на
себя-- и не удалиться, потому что глубокая очистка так и не запустилась до завершения работы программы

Вариант F: Объект подлежит сборке мусора, если в программе нет ссылок на него.

Данный вариант является верным, как мы говорили ранее это явно прописано в разделе 3, который называется "Реализация
сборщика мусора"

И вариант G: Переменная помеченная как final, означает что ассоциированный с ней объект не может быть подвергнут сборке
мусора

Данный вариант не является верным. К примеру локальная ссылочная переменная на объект внутри метода может быть помечена
как final и после выхода из метода объект может больше не иметь других ссылок и быть подвергнут сборке мусора

Соответственно правильными ответами на задачу являются варианты C, E и F
Поздравляю если вы выбрали именно их

Ставьте палец вверх, если вам понравилось это видео
Пишите комментарии, если узнали что - то новое
И подпишитесь на канал, если вам интересны подобные задачи

Удачи вам на экзамене
