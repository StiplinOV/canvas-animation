Задача про четвёрки

Представьте себе что у вас есть массив чисел.
Также у вас есть некоторое число, которое мы назовём целевой суммой.

Вам нужно из массива чисел выбрать 4 числа такие, что сумма этих четырёх чисел равна целевой сумме
Таких четвёрок чисел может быть несколько.
Задача найти все уникальные четвёрки чисел

В данной задаче указаны следующие ограничения:

1. количество элементов во входном массиве больше или равно одному, но меньше или равно двумста
2. каждый элемент набора - это число, которое меньше или равно десять в девятой степени, но больше или равно минус десять в девятой степени
3. Целевая сумма меньше или равна десять в девятой степени, но больше или равна минус десять в девятой степени

Рассмотрим решение данной задачи:

Ограничение о том, что количество элементов в исходном массиве не может превышать двести подсказывает нам, что данную задачу можно решать перебором
Если просто перебрать все варианты указателей, то вычислительная сложность данного алгоритма будет равна n в четвёртой степени 

Но что если я скажу что существует  наиболее эффективный способ решения данной задачи

Для того, чтобы рассмотреть его - решим такую же задачу, но для двух указателей
Вам нужно из массива чисел выбрать пары чисел такие, что сумма этой пары равна целевой сумме
И вернуть уникальные наборы таких пар

Поставьте видео на паузу и попробуйте решить эту задачу для двух указателей
Итак решение:
Отсортируем исходный набор, чтобы числа следовали по порядку от меньшего к большему
Объявим два указателя. Один будет смотреть на первый элемент, второй на последний
Возьмём пару чисел, на кототорые смотрят указатели и сравним их сумму с целевой.
Если сумма равна целевой - запоминаем эти числа для добавления в набор
Далее перемещаем левый указатель вправо, а правый указатель влево
Если сумма меньше целевой, двигаем левый указатель вправо, таким образом увеличивая сумму следующей пары чисел
Если сумма больше целевой, двигаем правый указатель влево, таким образом уменьшая сумму следующей пары чисел
Повторим сравнение пары чисел на которые смотрят указатели и снова будем осуществлять перемещение указателей
Данную процедуру повторяем до тех пор, пока левый и правый указатели не встретятся.
Данный алгоритм также можно оптимизировать.
Поскольку массив отсортирован, то при перемещении указателя можно пропускать повторяющиеся элементы. Это избавит от лишних действий.

Вычислительная сложность данного алгоритма будет равна сумме сложности сортировки (n*log) и одного прохода массива (то есть n). Итого суммарно сложность равна n*log(n)

Теперь, когда мы умеем решать задачу для двух указателей - можно оптимизировать решение задачи с четырьмя указателями 

1. Отсортируем исходный массив
2. Объявляем два указателя. Пусть первый указатель указывает на вервый элемент, а второй указатель на второй элемент
3. Вычтем из целевой суммы значение, расположенное по адресу первого и второго указателя. Назовём полученную величину новой целевой суммой
4. Решим задачу для двух указателей: левый указатель будет равен второму указателю из пункта 1, перемещенному на одну позицию вправо. Правый указатель будет указывать на последний элемент исходного массива. Целевая сумма будет равна новой целевой сумме. Каждую подходящую пару значений записываем в результат, вместе со значениями для указателей из пункта 1
5. Перемещаем второй указатель вправо. и повторяем пункты 3,4 и 5 до тех пор, пока второй указатель не упрётся в правую границу массива
6. Перемещаем первый указатель вправо, второй указатель на следующий элемент, идущий после первого указателя. Повторяем шаги 3, 4, 5 и 6 до тех пор, пока второй указатель не упрётся в правую границу массива
7. Возвращаем набор чисел, который был сформирован

Данный алгоритм также можно оптимизировать, если также пропускать повторяющиеся элементы при перемещении указателя 1 и 2

Вычислительная сложность данного алгоритма будет равна произведению сложности перемещения указателеё 1 и 2 (то есть n^2) умноженную на вычислительную сложность алгоритма поиска целевой суммы для двух указателей. То есть n^3*log(n)

Исходный код для решения данной задачи можно увидеть на экране, а также по ссылке в описании


(low++, high-- оптимизировать)



